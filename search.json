[
  {
    "objectID": "qmd/SQL/3_P2.html",
    "href": "qmd/SQL/3_P2.html",
    "title": "Practice - 2",
    "section": "",
    "text": "CodeChef SQL Basic Commands\nAll question under 1 Basic Commands in above link\nSubquery vs Join use\nJust above question can be solve using subquery, but that is costly, so use join\nDate Ordering\n\n\n\n\nSecond Highest Salary\nNumber of Unique Subjects Taught by Each Teacher\nSearch Insert Position",
    "crumbs": [
      "**SQL**",
      "Practice-2"
    ]
  },
  {
    "objectID": "qmd/SQL/3_P2.html#basic-practice",
    "href": "qmd/SQL/3_P2.html#basic-practice",
    "title": "Practice - 2",
    "section": "",
    "text": "CodeChef SQL Basic Commands\nAll question under 1 Basic Commands in above link\nSubquery vs Join use\nJust above question can be solve using subquery, but that is costly, so use join\nDate Ordering\n\n\n\n\nSecond Highest Salary\nNumber of Unique Subjects Taught by Each Teacher\nSearch Insert Position",
    "crumbs": [
      "**SQL**",
      "Practice-2"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html",
    "href": "qmd/SQL/1_AggregatesFunctions.html",
    "title": "SQL Aggregate Functions",
    "section": "",
    "text": "Note: SQL execution sequence will be :- From(and Join)-&gt; Where-&gt; Group By-&gt; Having-&gt; Select-&gt; Order By-&gt; Limit Key tip: WHERE filters rows, HAVING filters groups.",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#aggregate-functions-group-by-having-clause-reference",
    "href": "qmd/SQL/1_AggregatesFunctions.html#aggregate-functions-group-by-having-clause-reference",
    "title": "SQL Aggregate Functions",
    "section": "Aggregate Functions, GROUP BY & HAVING Clause (Reference)",
    "text": "Aggregate Functions, GROUP BY & HAVING Clause (Reference)\n\n\n\n\n\n\n\n\nFunction\nDescription\nResult if no rows found\n\n\n\n\nCOUNT(*)\nCounts total rows (includes NULLs)\n0\n\n\nCOUNT(col)\nCounts non-NULL values\n0\n\n\nSUM(col)\nSum of non-NULL values\nNULL\n\n\nAVG(col)\nAverage of non-NULL values\nNULL\n\n\nMIN(col)\nSmallest non-NULL value\nNULL\n\n\nMAX(col)\nLargest non-NULL value\nNULL\n\n\n\n\nNote:\nAll aggregate functions ignore NULL values except COUNT(*).",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#scalar-function-used-with-aggregates",
    "href": "qmd/SQL/1_AggregatesFunctions.html#scalar-function-used-with-aggregates",
    "title": "SQL Aggregate Functions",
    "section": "Scalar Function Used with Aggregates",
    "text": "Scalar Function Used with Aggregates\n\n\n\n\n\n\n\n\nExpression\nDescription\nResult if no rows found\n\n\n\n\nROUND(AVG(col), 2)\nRounds the average to 2 decimal places\nNULL\n\n\n\n\nNote:\nROUND() is not an aggregate function.\nIt is a scalar (numeric) function applied to an aggregate result.\nIf the aggregate result is NULL, ROUND(NULL) also returns NULL.",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#group-by-clause",
    "href": "qmd/SQL/1_AggregatesFunctions.html#group-by-clause",
    "title": "SQL Aggregate Functions",
    "section": "GROUP BY Clause",
    "text": "GROUP BY Clause\nThe GROUP BY clause is used to group rows that share the same values and apply aggregate functions to each group.\n\nExample\nSELECT department, AVG(salary)\nFROM employees\nGROUP BY department;\n\n\nImportant Rules\n\nEvery column in SELECT must be:\n\nIn the GROUP BY clause, or\nUsed inside an aggregate function\n\nIncorrect SELECT mode, SUM(amount) from payment\nCorrect SELECT mode, SUM(amount) from payment GROUP BY mode\nGROUP BY is evaluated after WHERE\nGROUP BY can use multiple columns\n\nGROUP BY department, job_title;",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#having-clause",
    "href": "qmd/SQL/1_AggregatesFunctions.html#having-clause",
    "title": "SQL Aggregate Functions",
    "section": "HAVING Clause",
    "text": "HAVING Clause\nThe HAVING clause is used to filter groups, not individual rows.\n\nExample\nSELECT department, AVG(salary)\nFROM employees\nGROUP BY department\nHAVING AVG(salary) &gt; 50000;",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#where-vs-having-very-important",
    "href": "qmd/SQL/1_AggregatesFunctions.html#where-vs-having-very-important",
    "title": "SQL Aggregate Functions",
    "section": "WHERE vs HAVING (Very Important)",
    "text": "WHERE vs HAVING (Very Important)\n\n\n\nWHERE\nHAVING\n\n\n\n\nFilters rows\nFilters groups\n\n\nUsed before grouping\nUsed after grouping\n\n\nCannot use aggregates\nCan use aggregates\n\n\n\n\nExample\nSELECT department, COUNT(*)\nFROM employees\nWHERE status = 'ACTIVE'\nGROUP BY department\nHAVING COUNT(*) &gt; 5;",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#query-execution-order-logical",
    "href": "qmd/SQL/1_AggregatesFunctions.html#query-execution-order-logical",
    "title": "SQL Aggregate Functions",
    "section": "Query Execution Order (Logical)",
    "text": "Query Execution Order (Logical)\n\nFROM\nWHERE\nGROUP BY\nHAVING\nSELECT\nORDER BY",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "qmd/SQL/1_AggregatesFunctions.html#key-exam-interview-takeaways",
    "href": "qmd/SQL/1_AggregatesFunctions.html#key-exam-interview-takeaways",
    "title": "SQL Aggregate Functions",
    "section": "Key Exam / Interview Takeaways",
    "text": "Key Exam / Interview Takeaways\n\nWHERE ‚Üí filters rows\nGROUP BY ‚Üí creates groups\nHAVING ‚Üí filters aggregated results\nAggregates return NULL if no rows exist (except COUNT)",
    "crumbs": [
      "**SQL**",
      "Aggregates Functions"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSA & SQL Learning",
    "section": "",
    "text": "üìò Data Structures, Algorithms & Databases\n(Python ‚Ä¢ DSA ‚Ä¢ SQL ‚Ä¢ PostgreSQL)\nThis website documents my learning journey in Data Structures, Algorithms, and Databases, using Python for problem-solving and PostgreSQL for SQL practice.\nI focus on building strong fundamentals through consistent practice, examples, and queries.\nYou can track my progress and solutions on my LeetCode üñ•Ô∏è account.\n\nüîπ What I‚Äôm Learning\n\nüß† Data Structures\n\n‚öôÔ∏è Algorithms\n\nüêò SQL & PostgreSQL\nüêç Advance Python\n\n\nüéØ Goal: Build strong problem-solving skills and database fundamentals for real-world applications and interviews.\n\n\nüìö Who can follow this journey: You must know the basic level of python, sql, dsa, and databases to follow this journey/roadmap.",
    "crumbs": [
      "**Agenda**"
    ]
  },
  {
    "objectID": "qmd/SQL/4_P3.html",
    "href": "qmd/SQL/4_P3.html",
    "title": "Practice - 3",
    "section": "",
    "text": "Aggregate Nesting\nDirect nesting of aggregate functions (like writing AVG(SUM(column))) isn‚Äôt allowed in SQL. Instead, you use subqueries or CTEs to achieve nested aggregation, and the depth is only limited by your database‚Äôs query nesting or recursion limits, which are typically very high and implementation-dependent.\nMin on Varchar\nMIN treats the varchar values as strings and finds the minimum value by comparing their characters from left to right ( lexicographical order ).\nWhen and Case\n\n\n\n\n181. Employees Earning More Than Their Managers\n1757. Recyclable and Low Fat Products\n2520. Count the Digits That Divide a Number\n34. Find First and Last Position of Element in Sorted Array\n11. Container With Most Water\n9. Palindrome Number",
    "crumbs": [
      "**SQL**",
      "Practice-3"
    ]
  },
  {
    "objectID": "qmd/SQL/4_P3.html#sql-practice",
    "href": "qmd/SQL/4_P3.html#sql-practice",
    "title": "Practice - 3",
    "section": "",
    "text": "Aggregate Nesting\nDirect nesting of aggregate functions (like writing AVG(SUM(column))) isn‚Äôt allowed in SQL. Instead, you use subqueries or CTEs to achieve nested aggregation, and the depth is only limited by your database‚Äôs query nesting or recursion limits, which are typically very high and implementation-dependent.\nMin on Varchar\nMIN treats the varchar values as strings and finds the minimum value by comparing their characters from left to right ( lexicographical order ).\nWhen and Case\n\n\n\n\n181. Employees Earning More Than Their Managers\n1757. Recyclable and Low Fat Products\n2520. Count the Digits That Divide a Number\n34. Find First and Last Position of Element in Sorted Array\n11. Container With Most Water\n9. Palindrome Number",
    "crumbs": [
      "**SQL**",
      "Practice-3"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "",
    "text": "Recyclable and Low Fat Products\nNumber of Unique Subjects Taught by Each Teacher\nEmployees Earning More Than Their Managers\n\n\n\n\n\nCustomer Who Visited but Did Not Make Any Transactions\nAverage Time of Process per Machine",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html#leetcode-practice-postgresql-aggregates",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html#leetcode-practice-postgresql-aggregates",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "",
    "text": "Recyclable and Low Fat Products\nNumber of Unique Subjects Taught by Each Teacher\nEmployees Earning More Than Their Managers\n\n\n\n\n\nCustomer Who Visited but Did Not Make Any Transactions\nAverage Time of Process per Machine",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html#q5.-average-time-of-process-per-machine",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html#q5.-average-time-of-process-per-machine",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "Q5. Average Time of Process per Machine",
    "text": "Q5. Average Time of Process per Machine\nSELECT a1.machine_id,\n       ROUND(AVG(a2.timestamp - a1.timestamp)::numeric, 3) AS processing_time\nFROM Activity a1\nJOIN Activity a2\n  ON a1.machine_id = a2.machine_id\n AND a1.process_id = a2.process_id\n AND a1.activity_type = 'start'\n AND a2.activity_type = 'end'\nGROUP BY a1.machine_id;\n\nPostgreSQL Type System and Aggregate Functions\nPostgreSQL uses a strict type system that requires explicit type casting when using functions with specific data type requirements. Unlike MySQL, PostgreSQL does not perform implicit type conversions.\n\n\nKey Concepts\nAggregate Function Return Types\n\nAVG() returns double precision (64-bit floating point)\nSUM() returns the same type as input values\nCOUNT() returns bigint\n\nROUND Function Overloading\n\nROUND(double precision) ‚Üí rounds to nearest integer (returns double precision)\nROUND(numeric) ‚Üí rounds to nearest integer (returns numeric)\nROUND(numeric, integer) ‚Üí rounds to specified decimal places (returns numeric)\nROUND(double precision, integer) ‚Üí does not exist ‚ùå\n\nType Casting Syntax\n\nvalue::type ‚Üí PostgreSQL-specific shorthand\nCAST(value AS type) ‚Üí ANSI SQL standard (portable)\n\n\n\nFunction Behavior Summary\nAVG(column)                    ‚Üí double precision\nROUND(double precision)        ‚Üí double precision (0 decimals)\nROUND(double precision, int)   ‚Üí ERROR: function does not exist\nROUND(numeric)                 ‚Üí numeric (0 decimals)\nROUND(numeric, int)            ‚Üí numeric (specified decimals) ‚úÖ\n\n\nCommon Patterns\n-- ‚ùå Wrong: Direct ROUND on AVG\nROUND(AVG(column), 2)\n\n-- ‚úÖ Correct: Cast to numeric first\nROUND(AVG(column)::numeric, 2)\n\n-- ‚úÖ Alternative: CAST syntax\nROUND(CAST(AVG(column) AS numeric), 2)",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html#interview-questions",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html#interview-questions",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "Interview Questions",
    "text": "Interview Questions\nQ1: Why does ROUND(AVG(amount), 2) fail in PostgreSQL but works in MySQL?\nPostgreSQL‚Äôs AVG() returns double precision, and ROUND(double precision, integer) doesn‚Äôt exist. MySQL automatically converts types. Solution: cast to numeric first: ROUND(AVG(amount)::numeric, 2).\nQ2: What‚Äôs the difference between double precision and numeric in PostgreSQL?\ndouble precision is a binary floating-point type (faster, approximate), while numeric is exact decimal arithmetic (slower, precise). Use numeric for money and exact calculations; use double precision for scientific/statistical work.\nQ3: How do you handle NULL values in PostgreSQL aggregates?\nAggregates ignore NULL by default. Use COALESCE(column, 0) to treat NULLs as zero, or COUNT(*) vs COUNT(column) to include/exclude NULLs. Use IS NULL / IS NOT NULL for comparisons (never = NULL).\nQ4: What‚Äôs the difference between ::type and CAST(value AS type)?\nBoth perform type conversion. ::type is PostgreSQL-specific shorthand (faster to write), while CAST() is ANSI SQL standard (portable across databases). Use CAST() for cross-database compatibility.\nQ5: Why use self-join in this query instead of window functions?\nSelf-join pairs start/end events explicitly. Alternative with window function:\nSELECT machine_id,\n       ROUND(AVG(CASE WHEN activity_type = 'end' \n                      THEN timestamp - LAG(timestamp) OVER (PARTITION BY machine_id, process_id)\n                 END)::numeric, 3)\nFROM Activity\nGROUP BY machine_id;",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html#postgresql-vs-mysql-key-differences",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html#postgresql-vs-mysql-key-differences",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "PostgreSQL vs MySQL Key Differences",
    "text": "PostgreSQL vs MySQL Key Differences\nType Coercion\n\nPostgreSQL: strict typing, explicit casting required\nMySQL: loose typing, automatic conversion\n\nNULL Handling\n\nPostgreSQL: NULL = NULL returns NULL (must use IS NULL)\nMySQL: similar, but mode-dependent behavior\n\nString Comparison\n\nPostgreSQL: case-sensitive by default\nMySQL: case-insensitive by default (collation-dependent)",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  },
  {
    "objectID": "qmd/SQL/2_AggreatesFunctionsP1.html#final-takeaways",
    "href": "qmd/SQL/2_AggreatesFunctionsP1.html#final-takeaways",
    "title": "Leetcode Practice - PostgreSQL Aggregates",
    "section": "Final Takeaways",
    "text": "Final Takeaways\n\nPostgreSQL enforces strict type safety ‚Äî no implicit conversions\nAggregate functions return specific data types ‚Äî know the return type\nFormatting numeric results requires explicit casting to numeric\nNULL comparisons need IS NULL/IS NOT NULL operators\nQueries working in MySQL may fail in PostgreSQL without type casts\nUse ::type for quick PostgreSQL scripts, CAST() for portable code",
    "crumbs": [
      "**SQL**",
      "Practice-1"
    ]
  }
]